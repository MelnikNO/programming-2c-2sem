# README.md

## Задание 1
С использованием борда [борд](https://https://replit.com/@zhukov/prog-4-lr2-1#main.py) сравнить реализации (рекурсивной и нерекурсивной) построения бинарного дерева с точки зрения эффективности работы алгоритма (время выполнения) двумя способами: 

"timeit" с помощью модуля timeit;
"complex-profiling" с помощью создания специальной оболочки для тестирования (matplotlib, setup_data, timeit).
Для второго способа следует переписать содержимое функции setup_data так, чтобы генерировались не списки чисел (в борде пример генерации данных для сравнения работы функции-факториала), а списки пар чисел (кортеж или словарь, представляющих root и height), также необходимо определить оптимальные значения параметров: количество «прогонов» тестов и длина списка с параметрами для построения деревьев.

Следует учесть замечания, отмеченные в конце борда.

Представить в качестве ответа: 

отдельными модулями реализации нерекурсивного и рекурсивного вариантов;
файлы с графиками, чтобы можно было понять какой алгоритм работает быстрее (внутри борда), графики строить по обоим вариантам ("timeit", "complex-profiling");
README.md файл (см. борд), в котором описать краткий отчет о проделанной работе и дать комментарии по поводу сравнения эффективности нерекурсивного и рекурсивного реализаций.

**Комментарий к основной программе:** При написании кода сложностей не возникло, т.к. был предоставлен борд и разборилось на занятиях. В функции "setup_data" отсутствует randit, как было указано в борде, поэтому использовалась функция zip. В основнрй функции измерялась работа рекурсивной и нерекурсивной функций генерации бинарных дереьев и строились графики результатов. Функции рекурсии и нерекурсии импортированы из ЛР1

**Результат основной программы:**


![code1](https://github.com/MelnikNO/programming-2c-2sem/blob/main/Screen/LR2/answer.png)

График

![code1](https://github.com/MelnikNO/programming-2c-2sem/blob/main/Screen/LR2/lr2results.png)


***Сравнение метода "timeit"***

Рекурсия:
`python -m timeit -n 100 -r 3 -u usec -s "from bintreerec import gen_bin_rec_tree" "gen_bin_rec_tree(height = 0)"`

![code1](https://github.com/MelnikNO/programming-2c-2sem/blob/main/Screen/LR2/timeitrec.png)

Нерекурсия:
`python -m timeit -n 100 -r 3 -u usec -s "from bintreenerec import gen_bin_nec_tree" "gen_bin_nec_tree(height = 0)"`

![code1](https://github.com/MelnikNO/programming-2c-2sem/blob/main/Screen/LR2/timeitnerec.png)

Excel
![code1](https://github.com/MelnikNO/programming-2c-2sem/blob/main/Screen/LR2/excel.png)

**Комментарий к тестам:** Сложности не возникло, но тесты были сделаны не только методом assertEqual. Это также способствовало к познанию другх функций для проведения тестов.

**Результат тестовой программы:**

Unittest 

![test_code1](https://github.com/MelnikNO/programming-2c-2sem/blob/main/Screen/LR2/unittest.png)


Pytest

![test_code1](https://github.com/MelnikNO/programming-2c-2sem/blob/main/Screen/LR2/pytest.png)


---

## Вывод
**По таблице:** Время выполнения как рекурсивного, так и нерекурсивного алгоритмов увеличивается с ростом высоты дерева. Это ожидаемо, поскольку увеличение высоты дерева обычно приводит к большему количеству операций. Выбор между рекурсией и нерекурсией должен основываться на конкретных требованиях задачи и размерах входных данных. Для малых деревьев рекурсия может быть более удобной и понятной, в то время как для больших деревьев нерекурсия будет предпочтительнее из-за своей стабильности и предсказуемости во времени выполнения.

**Программа:** Время выполнения обоих алгоритмов (рекурсивного и итеративного) остается на очень низком уровне, что указывает на высокую эффективность обоих подходов для рассматриваемых размеров дерева. Для небольших деревьев оба подхода работают достаточно быстро, но по мере увеличения размера дерева итеративный алгоритм демонстрирует явное преимущество в скорости выполнения. Рекомендуется использовать итеративный подход для больших деревьев из-за его большей эффективности и предсказуемости во времени выполнения. Рекурсия может оставаться удобной для небольших задач или случаев, когда важна простота кода.
